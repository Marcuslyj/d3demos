/*    @Description：风险预测，雷达图    @author: liyongjie*/export class RadarChart {    public svg;    public data;    public width = window.innerWidth;    public height = this.width * .85;    //外层网格半径    public radius = this.width * 0.3;    //网格数    public web_count;    //指标个数    public fieldNames_count;    //坐标轴范围    public rangeMin;    public rangeMax;    public arc = 2 * Math.PI;    // 相邻指标间的角度差    public arc_split;    public duration = 400;    constructor(svg, data, web_count = 5, range = [0, 100]) {        this.svg = svg;        this.data = data;        this.web_count = web_count;        this.fieldNames_count = data.fieldNames.length;        this.rangeMin = range[0];        this.rangeMax = range[1];        this.arc_split = this.arc / this.fieldNames_count;    }    //方法：取颜色    public getColor(idx) {        let palette = [            '#2196f3', '#f5a05a', '#5ab1ef'        ]        return palette[idx % palette.length];    }    public drawRadarChart_webs() {        let _this = this;        // 设置svg宽高        _this.svg.attr("width", "100%")            .attr("height", _this.height);        //主的绘图区        let g_main = _this.svg.append('g')            .classed('g_main', true)            .attr('transform', "translate(" + _this.width / 2 + ',' + _this.height * .55 + ')');        // 计算网轴的正多边形的坐标        let polygons = {            webs: [],            webPoints: []        };        for (let k = _this.web_count; k > 0; k--) {            let _webs = '',                _webPoints = [];            let r = _this.radius / _this.web_count * k;            for (let i = 0; i < _this.fieldNames_count; i++) {                let x = r * Math.sin(i * _this.arc_split),                    y = r * Math.cos(i * _this.arc_split);                _webs += x + ',' + y + ' ';                _webPoints.push({                    x: x,                    y: y                });            }            polygons.webs.push(_webs);            polygons.webPoints.push(_webPoints);        }        // 绘制网轴        let g_webs = g_main.append('g')            .classed('g_webs', true);        g_webs.selectAll('polygon')            .data(polygons.webs)            .enter()            .append('polygon')            .attr('points', function (d) {                return d;            });        // 添加纵轴        let g_lines = g_main.append('g')            .classed('g_lines', true);        g_lines.selectAll('line')            .data(polygons.webPoints[0])            .enter()            .append('line')            .attr('x1', 0)            .attr('y1', 0)            .attr('x2', function (d) {                return d.x;            })            .attr('y2', function (d) {                return d.y;            });        // 计算文字标签坐标        let textPoints = [];        let textRadius = _this.radius * 1.1;        for (let i = 0; i < _this.fieldNames_count; i++) {            let x = textRadius * Math.sin(i * _this.arc_split),                y = textRadius * Math.cos(i * _this.arc_split);            if (i === 0) {                y = (textRadius + .35 * (d3.select("body").style("font-size").replace("px", ""))) * Math.cos(i * _this.arc_split);            }            textPoints.push({                x: x,                y: y            });        }        // 绘制文字标签        let g_texts = g_main.append('g')            .classed('g_texts', true);        g_texts.selectAll('text')            .data(textPoints)            .enter()            .append('text')            .attr('x', function (d) {                return d.x;            })            .attr('y', function (d) {                return d.y;            })            .text(function (d, i) {                return _this.data.fieldNames[i];            })            ;        //文字标签对齐方式        let textTags = g_texts.selectAll('text');        textTags.each(function (data, i) {            if (0 < i && _this.fieldNames_count / 2 > i) {                d3.select(this).style("text-anchor", "start");            }            else if (i > _this.fieldNames_count / 2) {                d3.select(this).style("text-anchor", "end");            }        });        //计算刻度文字坐标        let axisPoints = [];        let axisRadius = _this.radius;        let axisRadiusSplit = axisRadius / _this.web_count;        for (let i = 0; i < _this.fieldNames_count; i++) {            let y = axisRadiusSplit * (i);            axisPoints.push({                x: -5,                y: (-1) * y + axisRadiusSplit * .3            });        }        //绘制刻度        let axisTexts = g_main.append('g')            .classed('axisTexts', true);        axisTexts.selectAll('text')            .data(axisPoints)            .enter()            .append('text')            .attr('x', function (d) {                return d.x;            })            .attr('y', function (d) {                return d.y;            })            .text(function (d, i) {                return _this.rangeMin + (_this.rangeMax - _this.rangeMin) / _this.web_count * i;            });        //绘制图例        let legend = g_main.append("g").classed("legend", true);        for (let i = _this.data.data.length - 1; i > -1; i--) {            let legendItem = legend.append("g").attr('transform', "translate(" + (_this.width * 0.28) + ',' + (-_this.height * .52 - _this.height * .05 * (i - 1)) + ')');            legendItem.append("text").text(_this.data.data[i].name);            legendItem.append("rect")                .attr("x", "-.65rem")                .attr("y", "-.53rem")                .attr("width", ".6rem")                .attr("height", ".6rem")                .attr("rx", ".1rem")                .attr("ry", ".1rem")                .attr("fill", _this.getColor(i));        }    }    public drawDataAreas() {        //重绘        if (this.svg.select(".g_areas")[0][0]) {            this.svg.selectAll(".g_areas").remove();        }        // 计算雷达图表的坐标        let _this = this;        let g_main = _this.svg.select(".g_main");        let areasData = [];        let values = _this.data.data;        for (let i = 0; i < values.length; i++) {            let value = values[i].values,                _area = '',                _points = [];            if (value === null || value === undefined) {                value = [];                value.length = _this.fieldNames_count;            }            for (let k = 0; k < _this.fieldNames_count; k++) {                value[k] = value[k] == null ? 0 : value[k];                let r = _this.radius * (value[k] - _this.rangeMin) / (_this.rangeMax - _this.rangeMin);                let x = r * Math.sin(k * _this.arc_split),                    y = r * Math.cos(k * _this.arc_split);                _area += x + ',' + y + ' ';                _points.push({                    x: x,                    y: y                })            }            areasData.push({                polygon: _area,                points: _points            });        }        // 添加g分组包含所有雷达图区域        let g_areas = g_main.append('g')            .classed('g_areas', true);        // 添加g分组用来包含一个雷达图区域下的多边形以及圆点        g_areas.selectAll('g')            .data(areasData)            .enter()            .append('g')            .attr('class', function (d, i) {                return 'area' + (i + 1);            });        for (let i = 0; i < areasData.length; i++) {            // 依次循环每个雷达图区域            let area = g_areas.select('.area' + (i + 1)),                areaData = areasData[i];            // 绘制雷达图区域下的多边形            area.append('polygon')                .attr('points', "0,0 0,0 0,0 0,0 0,0 0,0")                .attr('stroke', function (d, index) {                    return _this.getColor(i);                })                .attr('stroke-width', _this.width * .004)                .attr('fill', function (d, index) {                    return _this.getColor(i);                })                .transition()                .duration(_this.duration)                .attr('points', areaData.polygon);        }    }}
