<!DOCTYPE html><html>
 <head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no,minimum-scale=1.0, maximum-scale=1.0">  <title></title>  <link rel="stylesheet" type="text/css" href="css/styles.css" />  <style>   .bar {    fill: #2196f3;   }      .axis text {    font-size: .5rem;   }      .axis path,   .axis line {    fill: none;    stroke: #000;    shape-rendering: crispEdges;   }      /*.x.axis text {    transform: rotate(-28deg);    text-anchor: end !important;   }*/      g.g_line {    opacity: 0;   }      .no_display {    display: none;   }  </style> </head>
 <body>  <svg class="chart"></svg>
  <script src="js/d3.min.js" type="text/javascript" charset="utf-8"></script>  <script type="text/javascript">  var duration = 800;   windowWidth = window.innerWidth;   console.log(d3.select("body").style("font-size"));   var fontSize = d3.select("body").style("font-size").replace("px","");   var margin = {     top: windowWidth * .1,     right: windowWidth * .05,     bottom: windowWidth * .1,     left: windowWidth * .12    },    width = windowWidth - margin.left - margin.right,    height = windowWidth * .8 - margin.top - margin.bottom;   var tagWidth = width * .3;   var tagHeight = width * .1;   var tagGap = width * .02;    var tagColor = "rgba(0,0,0,.7)";
   var x = d3.scale.ordinal()    .rangeRoundBands([0, width], .4);   var y = d3.scale.linear()    .range([height, 0]);
   var chart = d3.select(".chart")    .attr("width", width + margin.left + margin.right)    .attr("height", height + margin.top + margin.bottom)    .append("g")    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
   var xAxis = d3.svg.axis()    .scale(x)    .orient("bottom");
   var yAxis = d3.svg.axis()    .scale(y)    .orient("left");
   var data = [{    name: "1月",    amount: 50000,    used:25000   }, {    name: "2月",    amount: 149000,    used:100000   }, {    name: "3月",    amount: 200100,    used:150000   }, {    name: "4月",    amount: 15000,    used:20500   }, {    name: "5月",    amount: 200000,    used:160000   }, {    name: "6月",    amount: 20000,    used:100000   }, {    name: "7月",    amount: 100000,    used:80000   }, {    name: "8月",    amount: 50000,    used:90000   }, {    name: "9月",    amount: 60000,    used:45000   }, {    name: "10月",    amount: 100000,    used:80000   }, {    name: "11月",    amount: 90000,    used:75000   }, {    name: "12月",    amount: 50000,    used:48000   }];
   x.domain(data.map(function(d) {    return d.name;   }));//   y.domain([0, d3.max(data, function(d) {//    return d.amount;//   })]);   var y_max = d3.max(data, function(d) {    return d.amount;   });   var y_remainder = y_max%20000;   var y_domain = [];   if(0==y_remainder){        y_domain = [0,y_max+20000];   }else{    y_domain = [0,20000-y_remainder+y_max];   }   y.domain(y_domain);       chart.append("g")    .attr("class", "x axis")    .attr("transform", "translate(0," + height + ")")    .call(xAxis);   chart.append("g")    .attr("class", "y axis")    .call(yAxis);   var g_bar = chart.append("g")    .classed("g_bar", true);   var bar = g_bar.selectAll(".bar")    .data(data)    .enter().append("rect")    .attr("class", "bar")    .attr("x", function(d) {     return x(d.name);    })    .attr("y", height)    .attr("height", 0)    .attr("width", x.rangeBand())    .transition().duration(duration)    .attr("y", function(d) {     return y(d.amount);    })    .attr("height", function(d) {     return height - y(d.amount);    });
   var targetLine = chart.append("g").classed("g_line", true);      var g_tag = targetLine.append("g").classed("g_tag", true);
   var valTagRect = g_tag.append("rect").classed("valTag", true);   valTagRect    .attr("x", tagGap)    .attr("y", 0)    .attr("width", tagWidth)    .attr("height", tagHeight)    .attr("rx", tagWidth * .05)    .attr("fill", tagColor);   targetLine.append("line")    .attr("x1", "0")    .attr("y1", "-.6rem")    .attr("x2", "0")    .attr("y2", height)    .attr("stroke", "red")    .attr("stroke-dasharray", "10 10");   var leftArrow = targetLine.append("polygon").classed("left-arrow",true)    .attr("fill", tagColor)    .attr("points", `0,${tagHeight/2} ${tagGap*1.015},${tagHeight/2-tagGap} ${tagGap*1.015},${tagHeight/2+tagGap}`);   var rightArrow = targetLine.append("polygon").classed("right-arrow",true)    .attr("fill", tagColor)    .attr("points", `0,${tagHeight/2} ${-tagGap*1.015},${tagHeight/2-tagGap} ${-tagGap*1.015},${tagHeight/2+tagGap}`);       var targetText = g_tag.append("text").classed("valText", true)    .text("")    .attr("transform", "translate(" + (tagGap + tagWidth / 2) + "," + (tagHeight/2+fontSize*.65/2) + ")")    .style("text-anchor", "middle")    .attr("fill", "white")    .style("font-size", ".65rem")    .style("font-weight",700);
   var svg = d3.select(".chart");   svg.on("touchstart", function() {    showTargetLine();
   });   svg.on("touchmove", function() {    showTargetLine();   });
   svg.on("touchend", function() {    targetLine     .style("transition", "2s")     .style("opacity", 0);   });
   function showTargetLine() {    //判断在纵坐标右边 或者减去margin.left和svg的left    var clientX = d3.event["changedTouches"][0].clientX - margin.left;    if (clientX < 0) {     return;    }    targetLine     .style("transition", "0s")     .style("opacity", 1);    //寻找最近的rect    var rects = g_bar.selectAll(".bar");    var targetRect;    var lastDelta;    rects.each(function(d, e) {     var thisRect = d3.select(this);     var centerLineX = Number(thisRect.attr("x")) + thisRect.attr("width") / 2;     var index;     if (!targetRect) {      targetRect = thisRect;      lastDelta = Math.abs(clientX - centerLineX);     }     var newDelta = Math.abs(clientX - centerLineX);     if (newDelta <= lastDelta) {      lastDelta = newDelta;      targetRect = thisRect;      rects.classed("target", false);      thisRect.classed("target", true);      targetLine.attr("transform", "translate(" + centerLineX + ",0)");
      targetText.text(d.amount+";"+d.used);      //过半      if (e > rects[0].length / 2) {       g_tag.attr("transform", "translate(" + -(tagGap * 2 + tagWidth) + ",0)");       leftArrow.classed("no_display", true);       rightArrow.classed("no_display", false);      } else {       g_tag.attr("transform", "translate(0,0)");       leftArrow.classed("no_display", false);       rightArrow.classed("no_display", true);      }     }    });   }        drawDotLine();   //(x,y)  => (rect中线x,y(d.used))  function drawDotLine(){   var rects = g_bar.selectAll(".bar");   var data = [];   rects.each(function(d,i){    var thisRect = d3.select(this);    data.push({     x:Number(thisRect.attr("x")) + thisRect.attr("width") / 2,     y:y(d.used)    });       });   console.log(data);      var g_dotline = chart.append("g").classed("g_dotline",true);//划线   var line = d3.svg.line()    .x(function(d) {     return d.x;    })    .y(function(d) {     return d.y;    });   g_dotline.append("path").classed("line", true)            .attr("stroke", "#ff6347")            .attr("fill","none")            .datum(data)            .attr("d", line)            .attr("stroke-width", ".1rem")            .attr("stroke-dasharray", function () {                //获取路径的总长度                return this.getTotalLength();            })            .attr("stroke-dashoffset", function () {                return this.getTotalLength();            })            .transition()            .ease("linear")            .duration(duration)            .attr("stroke-dashoffset", "0");            //画点               var g_dots = g_dotline.append("g").classed("g_dots",true);   g_dots.selectAll(".dot")   .data(data)   .enter()   .append("circle")   .attr("cx",function(d){    return d.x;   })//   .attr("cy",function(d){//    return d.y;//   })   .attr("cy",height)   .attr("r",".1rem")   .attr("fill","#f9a186")   .transition().ease("elastic").duration(duration)   .attr("cy",function(d){    return d.y;   })   .attr("r",".2rem")   ;  }      </script> </body>
</html>
